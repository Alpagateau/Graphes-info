\begin{enumerate}
    \item \includegraphics[width=0.5\textwidth]{figures/IMG_E0894.JPG}
     \includegraphics[width=0.5\textwidth]{figures/IMG_E0895.JPG}
    \item Dans la mesure où les graphes sont représentés en machine par leur matrice d'adjacence, on peut représenter un coloriage $f$ par un tableau qui à un sommet $i$ associe sa couleur, un entier entre 1 et $k$, s'il existe $k$ couleurs.
    \item \par
\scriptsize\begin{lstPython}
    def dessiner_graphe(canvas,matrice_graphe,coordonnees_sommets,coloration=None):
        N_sommets=len(matrice_graphe)
        symetrie=(matrice_graphe==matrice_graphe.T).all()
        
        if symetrie :
            for i in range(N_sommets):
                if matrice_graphe[i,i]==1:
                    dessiner_boucle(canvas,coordonnees_sommets[i]) 
                for j in range(i+1,N_sommets):
                    if matrice_graphe[i,j]==1:
                        dessiner_arc(canvas,coordonnees_sommets[i],coordonnees_sommets[j])    
        else : 
            for i in range(N_sommets):
                for j in range(N_sommets):
                    if matrice_graphe[i,j]==1 and i!=j:
                        dessiner_arc(
                            canvas,
                            coordonnees_sommets[i],
                            coordonnees_sommets[j],
                            fleche=True
                        )
                    if matrice_graphe[i,j]==1 and i==j:
                        dessiner_boucle(canvas,coordonnees_sommets[i],fleche=True)
        if coloration != None:  
            for i in range(N_sommets):
                dessiner_sommet(canvas,coordonnees_sommets[i],str(i+1), coloration[i])    
        else:
            for i in range(N_sommets):
                dessiner_sommet(canvas,coordonnees_sommets[i],str(i+1))

        return
\end{lstPython}\normalsize
    \item Ceci revient à compter le nombre d'applications d'un ensemble de cardinal $n$ à un ensemble de cardinal $3$. Pour chacun des $n$ antécédents il y a $3$ possibilités d'images. D'où ce nombre s'élevant à $3^n$.
    \item On munit l'ensemble des applications de $[1, n]$ vers $[1, 3]$ d'un ordre total, avec comme élément minimal une certaine application $f_0$. On manipulera \code{suivant} qui à une telle application associe sa suivante selon cet ordre, où bien $f_0$ si l'antécédent est maximal.\par
\begin{lstLNat}
    est3colorable(G : graphe) $\rightarrow$ booléen:
    début
        f $\leftarrow f_0$ 
        tant que suivant(f) != $f_0$ faire
        debut
            si est3coloriage(f, G):
                renvoyer vrai();
        fin
        renvoyer faux();
    fin
\end{lstLNat}
    \item On suppose que \code{est3coloriage} est de complexité constante (c'est facilement envisageable). Ainsi, puisqu'il existe $3^n$ coloriages pour un graphe à $n$ sommets, la complexité temporelle de \code{est3colorable} est en $\Theta(3^n)$~: elle est exponentielle en le nombre de sommets.
\end{enumerate} 